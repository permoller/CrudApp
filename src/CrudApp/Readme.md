# Automatic registration of entity types in EF Core
Types that inherit from EntityBase are automatically registered in Entity Framework in <code>CrudAppDbContext</code>.
There is no need to create DbSet properties for them.

# Entity ID
The entity IDs are not generated by the database, but by a static factory declared in <code>EntityBase</code>.
This makes some things simpler as we don't need a roundtrip to the database to get the ID.
But we do need to initialize the factory during startup.

The optimal type and generation algorithm to use for the ID is probably dependent on multiple factors including the database being used.
Currently the type long/Int64 is used for the id, but a global alias <code>EntityId</code> is used everywhere to make easy to change.

Some factors that may impact database performance are:
- Smaller keys require less space (they may be duplicated in many tables and indexes)
- Keys below 64 bits fits better in 64 bit processor architectures.
- Inserts may require more work to re-order the data (clustered index) if the keys are random than if they are sequential/ordered.

The current algorithm generates the IDs as a 63 bit positive integers containing a timestamp as the most significant bits,
followed by a generator ID (allowing multiple simultaious generators to co-exists)
and a counter (allowing multiple IDs to be generated within the same tick of the clock used for the timestamp).

**IMPORTANT**
If multiple instances of the service are running at the same time (like with horizontal scaling)
it is required that each instance is initialized with a different generator-id to ensure unique IDs are generated.

# Value converters
Properties in the entity types can be marked with custom attributes to add converters that allows storing enums as strings and objects as JSON in the database.
The attributes are detected and the converters added in <code>CrudAppDbContext</code>.

# EF Core Migrations
Requires [dotnet-ef tools](https://learn.microsoft.com/en-us/ef/core/cli/dotnet) which can be installed using:
<code>dotnet tool install --global dotnet-ef</code>

When the entities have changed a new migration step can be generated using this command from the src-folder:
<code>dotnet ef migrations add *NAME_OF_MIGRATION_STEP* --project .\CrudApp\ --output-dir Infrastructure\Database\Migrations</code>

# Optimistic Concurrency Control
The base type for all the entities (<code>EntityBase</code>) has a <code>Version</code> property.
The property is automatically updated in <code>CrudAppDbContext</code> when an entity is modified.
The property is used by EF Core to do optimistic concurrence control.
This means that when an entity is loaded, modified and saved back to the database, the action will fail if someone else has updated the entity.

**??? Does it work if an entity is received in a PUT request, which loads the entity, updates it and then saves the entity ???**

# Authentication
A custom authentication handler <code>UserIdAuthenticationHandler</code> have been made as a demonstration.
**It is not supposed to be used in a real application.**
It gives a simple way to make authenticated requests by adding a value like <code>UserId 123</code> to the Authrization header.


# Authorization


# Change tracking
When entity changes are saved to the database in <code>CrudAppDbContext</code>, the changes are detected and also saved to the database.
For each changed entity an <code>EntityChange</code> is saved along with a list of <code>PropertyChange</code>.

The attribute <code>SkipChangeTracking</code> can be applied to an entity or individual properties to disable change tracking.

# Generic filter/query functionality
Methods have been made that parses filtering and ordering expression-strings and applies them to an <code>IQueryable</code>.

This functionality is used in <code>QueryControllerBase</code>.
You can inherit from <code>QueryControllerBase</code> to expose this functionality for a custom database query as a web API endpoint.
<code>EntityControllerBase</code> inherits from <code>QueryControllerBase</code> to make this available for all exposed entities.

The filter expression-string is made up of a list of conditions.
A condition consists of a property-name, an opterator and a value like <code>Name EQ John Doe</code>.
Multiple conditions are combined with <code>AND</code> like <code>Name EQ John Doe AND Age GT 40</code>.

| Operator | Description |
| -- | -- |
| EQ | Equal |
| NE | Not equal |
| GT | Greater than |
| LT | Less than |
| GE | Greater than or equal |
| LE | Less than or equal |

Note that the operator-keywords and the AND-keyword must be upper case and have a single space before and after it.
Also note that if your value contains the word AND (upper case and with a space before and after) it will be miss-interpreted as the end of the condition and parsing the expression will likely fail.


The ordering expression string is a comma-seperated list of property-names like <code>Name,Age</code>.

The ordering is by default ascending.
Each property-name can optionally be followed by <code>desc</code> to order descending like <code>Name desc,Age</code>.

When ordering is used one can also use skip and take parameters to implement pagination.


# API exception handling
An exception filter (<code>ApiExceptionHandler</code>) handles the exceptions by converting them to [ProblemDetails](https://datatracker.ietf.org/doc/html/rfc7807) that are returned with an appropiate HTTP status code.

When there is an error message that should be returned from the API call one can throw the <code>ApiResponseException</code>.
It contains the HTTP status code and a message that will be returned to the client by the exception handler.

Other more specific exception types can also be made and handled to return more details.
An example is <code>ValidationException</code> which contains errors per property on an entity.
This is converted into a <code>ValidationProblemDetails</code> response with the errors.

It is also posible to throw a <code>NotAuthenticatedException</code> or <code>NotAuthorizedException</code>,
to trigger a challange or forbidden response.

Validation attributes can be added to the types received by the API.
If the controllers has the <code>ApiController</code> attribute (added to <code>CrudAppApiControllerBase</code>) and a request-model is not valid,
a <code>ValidationProblemDetails</code> object is returned with the errors.


# ASP.NET Integration tests
Automated integration tests have been made that starts an instance of the service that runs agains an in-memory SQLite database.

[WebApplicationFactory](https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-7.0) is used to start the service and modify the service registrations in the IoC container for external dependencies like the database.

# Snapshot tests
The test project uses snapshot-testing in some tests.

The package [Verify](https://github.com/VerifyTests/Verify) is used for snapshot testing.

As an example there is an integration test, that fetches the OpenApi document from the server.
It compares the document to a snapshot (an older verison of the document that gets checked into the source repository) and fails if anything has changed.
This test will allow you to detect unintentional changes to the API. If the change is intentional the new version can be accepted and the test will pass the next time it is run.

If a test fails when running locally a diff tool will be opened where the newly received snapshot is compared to the old verified snapshot.
Different diff tools are supported. Which diff tool will be used, is described at https://github.com/VerifyTests/DiffEngine/blob/main/docs/diff-tool.order.md.

How you actually accept the changes depends. See https://github.com/VerifyTests/Verify#snapshot-management.
With Rider and VisualStudio with ReSharper there is integration directly in the test-runner panel in the IDE to accept changes on failed tests.
With [WinMerge](https://winmerge.org/) you click a button in the diff-window to copy the new snapshot to the verified snapshot.


# Package dependencies
- Microsoft.EntityFrameworkCore.Sqlite: Sqlite is used as an in-memory database when executing automated tests.
- Microsoft.EntityFrameworkCore.Design: Required when using EF Core Migrations to update the database schema.
- Swashbuckle.AspNetCore: Used for exposing OpenAPI documentation and Swagger UI.
- Verify: Used for snapshot testing.

