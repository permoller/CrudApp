This is an ASP.NET Core application where I have been experimenting with implementing various features/functionality.

Using the features are not nessesarely recommended. They are just experiments. And the code have not been used in production.

# Entity ID

The entity IDs are not generated by the database, but by a static factory declared in <code>EntityBase</code>.
This makes some things simpler as we don't need a roundtrip to the database to get the ID.
But we do need to initialize the factory during startup.

The optimal type and generation algorithm to use for the ID is probably dependent on multiple factors including the database being used.
Currently the type long/Int64 is used for the id, but a global alias <code>EntityId</code> is used everywhere to make easy to change.

Some factors that may impact database performance are:

- Smaller keys require less space (they may be duplicated in many tables and indexes)
- Keys below 64 bits fits better in 64 bit processor architectures.
- Inserts may require more work to re-order the data (clustered index) if the keys are random than if they are sequential/ordered.

The current algorithm generates the IDs as a 63 bit positive integers containing a timestamp as the most significant bits,
followed by a generator ID (allowing multiple simultaious generators to co-exists)
and a counter (allowing multiple IDs to be generated within the same tick of the clock used for the timestamp).

**IMPORTANT**
If multiple instances of the application are running at the same time (like with horizontal scaling)
it is required that each instance is initialized with a different generator-id to ensure unique IDs are generated.

# Automatic registration of entity types in EF Core

Types that inherit from <code>EntityBase</code> are automatically registered in Entity Framework in <code>CrudAppDbContext</code>.
There is no need to create DbSet properties for them.

# Automatic eager loading non-nullable navigation properties

If a navigation-property on an entity is not marked as nullable, it is configured to always be eager loaded in <code>CrudAppDbContext</code>.

# EF Core - Value converters

Properties in the entity types can be marked with custom attributes to add converters that allows storing enums as strings (<code>EnumValueConverter</code>) and objects as JSON (<code>JsonValueConverter</code>) in the database.
The attributes are detected and the converters added in <code>CrudAppDbContext</code>.

# Database migrations

Requires [dotnet-ef tools](https://learn.microsoft.com/en-us/ef/core/cli/dotnet) which can be installed using:
<code>dotnet tool install --global dotnet-ef</code>

When the entities have changed a new migration step can be generated using this command from the src-folder:
<code>dotnet ef migrations add _NAME_OF_MIGRATION_STEP_ --project .\CrudApp\ --output-dir Infrastructure\Database\Migrations</code>

# Optimistic Concurrency Control

The base type for all the entities (<code>EntityBase</code>) has a <code>Version</code> property.
The property is automatically updated in <code>CrudAppDbContext</code> when an entity is modified.
The property is used by EF Core to do optimistic concurrence control.
This means that when an entity is loaded, modified and saved back to the database, the action will fail if someone else has updated the entity.

**??? Does it work if an entity is received in a PUT request, which loads the entity, updates it and then saves the entity ???**
**WARNING: Updating the version does not always work correctly for changes to navigation properties**

# Authentication

A custom authentication handler <code>UserIdAuthenticationHandler</code> have been made as a demonstration.
**It is not supposed to be used in a real application.**
It gives a simple way to make authenticated requests by adding a value like <code>UserId 123</code> to the Authrization header.

# Authorization

# Change tracking / Audit log

When entity changes are saved to the database in <code>CrudAppDbContext</code>, the changes are detected and also saved to the database.
For each changed entity an <code>EntityChange</code> is saved along with a list of <code>PropertyChange</code>.

The attribute <code>SkipChangeTracking</code> can be applied to an entity or individual properties to disable change tracking.

**WARNING: This detecting and saving changes for navigation properties does not always work correctly**

# Generic filter/query functionality

Methods have been made that parses filtering and ordering expression-strings and applies them to an <code>IQueryable</code>.

This functionality is used in <code>QueryControllerBase</code>.
You can inherit from <code>QueryControllerBase</code> to expose this functionality for a custom database query as a web API endpoint.
<code>EntityControllerBase</code> inherits from <code>QueryControllerBase</code> to make this available for all exposed entities.

The filter expression-string is made up of a list of conditions.
A condition consists of a property-name, an opterator and a value like <code>Name EQ John Doe</code>.
Multiple conditions are combined with <code>AND</code> like <code>Name EQ John Doe AND Age GT 40</code>.

| Operator | Description           |
| -------- | --------------------- |
| EQ       | Equal                 |
| NE       | Not equal             |
| GT       | Greater than          |
| LT       | Less than             |
| GE       | Greater than or equal |
| LE       | Less than or equal    |

Note that the operator-keywords and the AND-keyword must be upper case and have a single space before and after it.
Also note that if your value contains the word AND (upper case and with a space before and after) it will be miss-interpreted as the end of the condition and parsing the expression will likely fail.

The ordering expression string is a comma-seperated list of property-names like <code>Name,Age</code>.

The ordering is by default ascending.
Each property-name can optionally be followed by <code>desc</code> to order descending like <code>Name desc,Age</code>.

When ordering is used one can also use skip and take parameters to implement pagination.

# Logging

The application uses <code>ILogger</code> for logging.

<code>SinkLoggerProvider</code> has been made as an example of a custom implementation of <code>ILoggerProvider</code>.

The loggers it creates transforms the log-events into a <code>LogEntry</code> that reuses some of the fields from the [Elastic Common Schema](https://www.elastic.co/guide/en/ecs/current/ecs-field-reference.html).

Multiple <code>ILogSink</code> can be registered. They will receive the <code>LogEntry</code> so they can be logged to different locations. There are two examples:
- <code>TextWriterLogSink</code> writes the <code>LogEntry</code> as JSON or as plain text to a <code>TextWriter</code> (configured as plain text to <code>Console.Out</code> in the code).
- <code>OpenSearchBufferLogSink</code> writes the <code>LogEntry</code> as JSON to an in-memory buffer that periodicly is send to an OpenSearch server that can be started using <code>crud-app-dev-env/docker-compose.yml</code>.

NOTE that the default console logger that comes with .NET can be configured to log as JSON. So if your tooling can handle the JSON from it, it is probably a better choice than roling your own.

# API exception handling

An exception filter (<code>ApiExceptionHandler</code>) handles the exceptions by converting them to [ProblemDetails](https://datatracker.ietf.org/doc/html/rfc7807) that are returned with an appropiate HTTP status code.

When there is an error message that should be returned from the API call one can throw the <code>ApiResponseException</code>.
It contains the HTTP status code and a message that will be returned to the client by the exception handler.

Other more specific exception types can also be made and handled to return more details.
An example is <code>ValidationException</code> which contains errors per property on an entity.
This is converted into a <code>ValidationProblemDetails</code> response with the errors.

It is also posible to throw a <code>NotAuthenticatedException</code> or <code>NotAuthorizedException</code>,
to trigger a challange or forbidden response.

Validation attributes can be added to the types received by the API.
If the controllers has the <code>ApiController</code> attribute (added to <code>CrudAppApiControllerBase</code>) and a request-model is not valid,
a <code>ValidationProblemDetails</code> object is returned with the errors.

# ASP.NET Integration tests

Automated integration tests have been made that starts an instance of the application that runs against an in-memory SQLite database.

[WebApplicationFactory](https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-7.0) is used to start the application and modify the service registrations in the IoC container for external dependencies like the database.

A new instance of the application with its own in-memory database can be created using <code>WebAppFixture</code>.
It can be created in individual tests or reused with <code>IClassFixture</code> or <code>ICollectionFixture</code>.
By reusing an instance, test run against the same database so they may influence each other. But it will also save time by not having to start a new instance.

The server log-output that happens during test execution is captured and written to the output of the individual tests.

# Snapshot tests

The test project uses snapshot-testing in some tests.

The package [Verify](https://github.com/VerifyTests/Verify) is used for snapshot testing.

As an example there is an integration test, that fetches the OpenApi document from the server.
It compares the document to a snapshot (an older verison of the document that gets checked into the source repository) and fails if anything has changed.
This test will allow you to detect unintentional changes to the API. If the change is intentional the new version can be accepted and the test will pass the next time it is run.

If a test fails when running locally a diff tool will be opened where the newly received snapshot is compared to the old verified snapshot.
Different diff tools are supported. Which diff tool will be used, is described at https://github.com/VerifyTests/DiffEngine/blob/main/docs/diff-tool.order.md.

How you actually accept the changes depends. See https://github.com/VerifyTests/Verify#snapshot-management.
With Rider and VisualStudio with ReSharper there is integration directly in the test-runner panel in the IDE to accept changes on failed tests.
With [WinMerge](https://winmerge.org/) you click a button in the diff-window to copy the new snapshot to the verified snapshot.

# OpenAPI / Swagger

OpenAPI documentation and Swagger UI is exposed.

In <code>OpenApiServiceCollectionExtensions</code> OpenAPI is configured to take advantage of nullable reference types and maintain type inheritance in the generated schemas.
This allows generating client code (like for C# or Typescript) that better matches the C# types used by the server.

<code>ResponseMetadataProvider</code> is used to add default details regarding the response status codes and types, like the ProblemDetails response returned from <code>ApiExceptionHandler</code>.

<code>AuthenticationServiceColectionExtensions</code> configures the authentication information, so you can authenticate when using Swagger UI.

# Package dependencies

- Microsoft.EntityFrameworkCore.Sqlite: Sqlite is used as an in-memory database when executing automated tests.
- Microsoft.EntityFrameworkCore.Design: Required when using EF Core Migrations to update the database schema.
- Swashbuckle.AspNetCore: Used for exposing OpenAPI documentation and Swagger UI.
- Xunit: Used for running automated tests.
- Verify: Used for snapshot assertions in tests.
- Microsoft.AspNetCore.Mvc.Testing: Used for starting the application in integration tests.
