This is an ASP.NET Core application where I have been experimenting with implementing various features/functionality.

Using the features are not nessesarely recommended. They are just experiments. And the code have not been used in production.

# Entity ID

The entity IDs are not generated by the database, but by a static factory declared in `EntityBase`.
This makes some things simpler as we don't need a roundtrip to the database to get the ID.
But we do need to initialize the factory during startup.

The optimal type and generation algorithm to use for the ID is probably dependent on multiple factors including the database being used.
Currently the type long/Int64 is used for the id, but a global alias `EntityId` is used everywhere to make easy to change.

Some factors that may impact database performance are:

- Smaller keys require less space (they may be duplicated in many tables and indexes)
- Keys below 64 bits fits better in 64 bit processor architectures.
- Inserts may require more work to re-order the data (clustered index) if the keys are random than if they are sequential/ordered.

The current algorithm generates the IDs as a 63 bit positive integers containing a timestamp as the most significant bits,
followed by a counter (allowing multiple IDs to be generated within the same tick of the clock used for the timestamp)
and a generator ID (allowing multiple simultaious generators to co-exists).

**IMPORTANT**
If multiple instances of the application are running at the same time
it is required that each instance is initialized with a different generator-id to ensure unique IDs are generated.

# Automatic registration of entity types in EF Core

Types that inherit from `EntityBase` are automatically registered in Entity Framework in `CrudAppDbContext`.
There is no need to create DbSet properties for them.

# Automatic eager loading non-nullable navigation properties

If a navigation-property on an entity is not marked as nullable, it is configured to always be eager loaded in `CrudAppDbContext`.

# EF Core - Value converters

Properties in the entity types can be marked with custom attributes to add converters that allows storing enums as strings (`EnumValueConverter`) and objects as JSON (`JsonValueConverter`) in the database.
The attributes are detected and the converters added in `CrudAppDbContext`.

# Database migrations

Requires [dotnet-ef tools](https://learn.microsoft.com/en-us/ef/core/cli/dotnet) which can be installed using:
`dotnet tool install --global dotnet-ef`

When the entities have changed a new migration step can be generated using this command from the src-folder:
`dotnet ef migrations add _NAME_OF_MIGRATION_STEP_ --project .\CrudApp\ --output-dir Infrastructure\Database\Migrations`

# Optimistic Concurrency Control

The base type for all the entities (`EntityBase`) has a `Version` property.
The property is automatically updated by `CrudAppDbContext` when a modified entity is saved to the database.
The property is used by EF Core to do optimistic concurrence control.
This means that when an entity is loaded, modified and saved back to the database, the action will fail if someone else has updated the entity.

**WARNING**: Automatically updating the version does not always work correctly for changes to navigation properties. Especially if the object pointed to is removed. To be safe, update the version of the root entity manually og change its state in EF to modified.

# Authentication

A custom authentication handler `UserIdAuthenticationHandler` have been made as a demonstration.
**It is not supposed to be used in a real application.**
It gives a simple way to make authenticated requests by adding a value like `UserId 123` to the Authrization header.

# Authorization

TODO

# Change tracking / Audit log

When entity changes are saved to the database in `CrudAppDbContext`, the changes are detected and also saved to the database.
For each changed entity an `EntityChange` is saved along with a list of `PropertyChange`.

The attribute `SkipChangeTracking` can be applied to an entity or individual properties to disable change tracking.

**WARNING: This detecting and saving changes for navigation properties does not always work correctly**

# Generic CRUD functionality

`EntityControllerBase<T>` can be used as the base type for a controller where T is the entity type (inherits from `EntityBase`). This will then expose POST, GET, PUT and DELETE endpoints to perform create, read, update and delete operations.


# Soft Delete

The `EntityBase` type has a property named `IsSoftDeleted`. When the endpoint to delete an entity is called it sets this property instead of actually deleting the entity from the database.

The endpoints to get and query entities for entities will, by default, not return entities that have been soft deleted. But they have parameters that enable the soft deleted entities to be included in the results.

Once an entity has been soft deleted it can no longer be updated using the update endpoint.

# Generic filter/query functionality

Methods have been made that parses filtering and ordering expression-strings and applies them to an `IQueryable`.

This functionality is used in `QueryControllerBase`.
You can inherit from `QueryControllerBase` to expose this functionality for a custom database query as a web API endpoint.
`EntityControllerBase` inherits from `QueryControllerBase` to make this available for all exposed entities.

The filter expression-string is made up of a list of conditions.
A condition consists of a property-name, an opterator and a value like `Name EQ John Doe`.
Multiple conditions are combined with `AND` like `Name EQ John Doe AND Age GT 40`.

| Operator | Description           |
| -------- | --------------------- |
| EQ       | Equal                 |
| NE       | Not equal             |
| GT       | Greater than          |
| LT       | Less than             |
| GE       | Greater than or equal |
| LE       | Less than or equal    |

Note that the operator-keywords and the AND-keyword must be upper case and have a single space before and after it.
Also note that if your value contains the word AND (upper case and with a space before and after) it will be miss-interpreted as the end of the condition and parsing the expression will likely fail.

The ordering expression string is a comma-seperated list of property-names like `Name,Age`.

The ordering is by default ascending.
Each property-name can optionally be followed by `desc` to order descending like `Name desc,Age`.

When ordering is used one can also use skip and take parameters to implement pagination.

# Logging

The application uses `ILogger` for logging.

`SinkLoggerProvider` has been made as an example of a custom implementation of `ILoggerProvider`.

The loggers it creates transforms the log-events into a `LogEntry` that reuses some of the fields from the [Elastic Common Schema](https://www.elastic.co/guide/en/ecs/current/ecs-field-reference.html).

If an exception is logged the `Exception.Message` and `Exception.Data` are combined for the exception and inner exceptions and added to `LogEntry.Error.Message`, making it easy to log the messages and data.
If you want the full stacktrace you get from calling `Exception.ToString()` that is included in `LogEntry.Error.Stacktrace`. Note that the stacktrace does not include the data that might be added to the exceptions.


Multiple `ILogSink` can be registered. They will receive the `LogEntry` so they can be logged to different locations. There are two examples:
- `TextWriterLogSink` writes the `LogEntry` as JSON or as plain text to a `TextWriter` (configured as plain text to `Console.Out` in the code).
- `OpenSearchBufferLogSink` writes the `LogEntry` as JSON to an in-memory buffer that periodicly is send to an OpenSearch server that can be started using `crud-app-dev-env/docker-compose.yml`. This will only be enabled if the configuration `OpenSearchOptions:BaseAddress` is set.

NOTE that the default console logger that comes with .NET can be configured to log as JSON. So if your tooling can handle the JSON from it, it is probably a better choice than roling your own.

# Model validation

Validation attributes can be added to the types received by the API.
If the controllers has the `ApiController` attribute (which is added to `CrudAppApiControllerBase`) the model is automatically validated.
If a request-model is not valid a `ProblemDetails` object is returned with the validation errors.

# API exception handling

An exception filter (`ApiExceptionHandler`) handles the exceptions thrown by controllers.
The exceptions are converted to `ProblemDetails` which are then returned to the client.

When there is a message that should be returned included in the response one can throw an `ApiResponseException`.
It contains the HTTP status code and a message that will be returned to the client in the `ProblemDetails` response.
The message also includes the key-value pairs from `Exception.Data` and messages (and data) from inner-exceptions of type `ApiResponseException`.

Other more specific exception types can also be made and handled to return more details.
An example is `ValidationException` which contains errors per property on an entity.
This is converted into a `ValidationProblemDetails` response with the errors.

It is also posible to throw a `NotAuthenticatedException` or `NotAuthorizedException`,
to trigger a challange or forbidden response.


# Return types: Result, Error, Maybe and Nothing
To allow coding with fewer exceptions, some types have been made to help.

Configurations have been made to handle these types specially in the WebAPI pipeline.
Instead of returning them directly they are "unwrapped" and the appropiate response is returned to the client.
The WebAPI metadata of all the actions is also updated to support generating the correct OpenAPI documentation.

`Result<T>` is used as the return type on functions that may either return a result of type `T` or an `Error`.
This is an alternative to throwing and catching exceptions.
A number of extenstion methods have been made that allows chaining of multiple functions that returns `Result<T>` without having to manually check the results for error every time.
If `Result<T>` is returned by a controller action-method, the inner value of type `T` or the inner `Error` will be returned.

`Error` is an abstract base type used for errors that may be returned to the client.
All the different subtypes are defined in `Error.Types.cs`. The subtypes define the HTTP status code to be returned along with relevant data like the type and id of an entity.
If `Error` is returned by a controller action-method (directly or through `Result<T>` the error is converted to a `ProblemDetails` response.

`Nothing` is used as the generic type parameter in `Result<T>` for methods that does not have a return value, but still may return an `Error`.
If `Nothing` is returned from a controller action-method (throgh `Result<Nothing>`) a "No Content" response is returned.

`Meybe<T>` is like `Nullable<T>` but for reference types. Returning `Maybe<T>` instead of `T` makes it clear that there may not be anything to return.
If `Maybe<T>` is returned from a controller action-method (directly or through `Result<T>`) the response to the client will either be the inner object or a "No content" response.



# ASP.NET Integration tests

Automated integration tests have been made that starts an instance of the application that runs against an in-memory SQLite database.

[WebApplicationFactory](https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-7.0) is used to start the application and modify the service registrations in the IoC container for external dependencies like the database.

A new instance of the application with its own in-memory database can be created using `WebAppFixture`.
It can be created in individual tests or reused with `IClassFixture` or `ICollectionFixture`.
By reusing an instance, test run against the same database so they may influence each other. But it will also save time by not having to start a new instance.

The server log-output that happens during test execution is captured and written to the output of the individual tests.

# Snapshot tests

The test project uses snapshot-testing in some tests.

The package [Verify](https://github.com/VerifyTests/Verify) is used for snapshot testing.

As an example there is an integration test, that fetches the OpenApi document from the server.
It compares the document to a snapshot (an older verison of the document that gets checked into the source repository) and fails if anything has changed.
This test will allow you to detect unintentional changes to the API. If the change is intentional the new version can be accepted and the test will pass the next time it is run.

If a test fails when running locally a diff tool will be opened where the newly received snapshot is compared to the old verified snapshot.
Different diff tools are supported. Which diff tool will be used, is described at https://github.com/VerifyTests/DiffEngine/blob/main/docs/diff-tool.order.md.

How you actually accept the changes depends. See https://github.com/VerifyTests/Verify#snapshot-management.
With Rider and VisualStudio with ReSharper there is integration directly in the test-runner panel in the IDE to accept changes on failed tests.
With [WinMerge](https://winmerge.org/) you click a button in the diff-window to copy the new snapshot to the verified snapshot.

# OpenAPI / Swagger

OpenAPI documentation and Swagger UI is exposed.

In `OpenApiServiceCollectionExtensions` OpenAPI is configured to take advantage of nullable reference types and maintain type inheritance in the generated schemas.
This allows generating client code (like for C# or Typescript) that better matches the C# types used by the server.

`ResponseMetadataProvider` is used to add default details regarding the response status codes and types, like the ProblemDetails response returned from `ApiExceptionHandler`.

`AuthenticationServiceColectionExtensions` configures the authentication information, so you can authenticate when using Swagger UI.

# Package dependencies

- Microsoft.EntityFrameworkCore.Sqlite: Sqlite is used as an in-memory database when executing automated tests.
- Microsoft.EntityFrameworkCore.Design: Required when using EF Core Migrations to update the database schema.
- Swashbuckle.AspNetCore: Used for exposing OpenAPI documentation and Swagger UI.
- Xunit: Used for running automated tests.
- Verify: Used for snapshot assertions in tests.
- Microsoft.AspNetCore.Mvc.Testing: Used for starting the application in integration tests.
